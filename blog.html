<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="blog.css" />
    <title>Nick Wilder - Blog</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:ital&family=Kotta+One&family=Lilita+One&display=swap"
      rel="stylesheet"
    />
    <link rel="icon" type="image/x-icon" href="favicon/favicon.ico" />
  </head>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-130R11B1E9"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
      dataLayer.push(arguments);
    }
    gtag("js", new Date());

    gtag("config", "G-130R11B1E9");
  </script>
  <body>
    <div class="intro">
      <h1 class="introTitle">Blog</h1>
      <div>
        Blog will contain notes from books, courses, and maybe occasional random thoughts. Most of the notes will come
        from my Obsidian vault served here as a backup using
        <a href="https://markdowntohtml.com/">markdowntohtml.com</a> with minimal extra formatting.
      </div>
      <br />
      <div>Notes will be added as I think they are relevant and polished enough to publish.</div>
      <h3>Table of Contents</h3>
      <ul>
        <li><a href="#business-writing">Becoming an Effective Writer - 06/24/2024</a></li>
        <li><a href="#contract-testing">Contract Testing in Action - 11/02/2024</a></li>
        <li><a href="#">Powershell Scripting and Toolmaking - Also maybe soon?</a></li>
      </ul>
    </div>
    <hr />

    <section class="post" id="business-writing">
      <h1 class="postTitle">Becoming an Effective Writer</h1>
      <h2>What is and is not Business Writing?</h2>
      <ul>
        <li>Is not meant to entertain or reflect; this is pleasure writing.</li>
        <li>Is meant to get facts straight and to the point, to inform or to persuade the reader.</li>
      </ul>
      <p>
        Regular consistent practice is necessary. Changing habits is not easy; you have to be willing to change, know
        how to change, and practice. &quot;Practice makes perfect&quot;
      </p>
      <table>
        <thead>
          <tr>
            <th>Readers</th>
            <th>Writers</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Scan for key points</td>
            <td>Be clear and simple</td>
          </tr>
          <tr>
            <td>Quickly decide importance</td>
            <td>Get to the point</td>
          </tr>
        </tbody>
      </table>
      <p>In order to succeed in business, you must be able not just to write, but to write effectively.</p>
      <h2>Principles of Business Writing</h2>
      <ol>
        <li>
          Analyze the reader
          <ul>
            <li>What does my reader already know? Who is my audience?</li>
          </ul>
        </li>
        <li>
          Organize the message
          <ul>
            <li>
              Does your message begin with a purpose, organize the message in the best way for the reader, and look easy
              to read?
            </li>
          </ul>
        </li>
        <li>
          Signal the next step
          <ul>
            <li>Is there a time when a response is needed and does it contain contact information?</li>
          </ul>
        </li>
        <li>
          Value the reader
          <ul>
            <li>
              Effective business writers need to give the impression that the reader is important and not just another
              number.
            </li>
          </ul>
        </li>
        <li>
          Ensure an effective message
          <ul>
            <li>Decrease the need for follow-up messages.</li>
          </ul>
        </li>
        <li>
          Choose the right channel
          <ul>
            <li>Email, Teams, Meeting, or Face to Face</li>
          </ul>
        </li>
      </ol>
      <h2>The 10 C&#39;s of Business Writing</h2>
      <p>
        A writer has the right to expect every message to be: Complete, Concise, Clear, Conversational, Courteous,
        Correct, Considerate, Concrete, and Credible.
      </p>
      <ol>
        <li>Complete: Is all of the information included so that follow-up questions are not necessary?</li>
        <li>
          Concise: Use the fewest number of words possible. Including more words into your writing leads the reader to
          have to wade through information that may not be relevant to the writing.
        </li>
        <li>
          Clear: Have you thought about what the reader knows or doesn&#39;t know, or are you writing based on what you
          know and what makes sense to you?
        </li>
        <li>Conversational: Does your writing sound as if you are writing to a human or to a robot?</li>
        <li>
          Courteous: Is your tone pleasant? Have you shown the reader how they will benefit from your information or
          policy? Does the message sound demanding or is it all about the writer&#39;s interest?
        </li>
        <li>
          Correct: Is your writing accurate and professional, or does it give the impression that it was rushed and not
          prepared?
        </li>
        <li>Coherent: Does your writing look jumbled or do the ideas tie together smoothly?</li>
        <li>
          Considerate: Does your writing look inviting to read (using headings and bullets) or does it use 1 or 2 long
          paragraphs?
        </li>
        <li>Concrete: Have you included specifics and examples, or are vague meaningless words used?</li>
        <li>Credible: Are all facts within the article given from trusted sources and cited?</li>
      </ol>
      <h2>Strong vs. Weak Verbs</h2>
      <p>Which of the following statements sound stronger and more concise?</p>
      <p>
        (a) You will need to send your confirmation for your appointment by Friday. (b) Please confirm your appointment
        by Friday.
      </p>
      <p>
        12 words versus 6 words. Not only is (b) stronger, the message is more concise. Look for camouflaged words in
        your message, verbs that have usually turned into nouns, commonly adding the -tion at the end of the word.
        Conversation versus confirm.
      </p>
      <p>The same principle applies for filler words.</p>
      <p>(a) There are five people who want to attend the meeting. (b) Five people want to attend the meeting.</p>
      <p>Make your writing more concise, cut out the fluff and get to the point.</p>
      <h2>Create a Clear Message</h2>
      <p>Understand your reader and their ability to comprehend what you&#39;re trying to tell them.</p>
      <ul>
        <li>What department do they work for?</li>
        <li>What is their experience within the topic you&#39;re talking about?</li>
        <li>What relationship do you have with the reader?</li>
      </ul>
      <p>
        Make your message logical and easy to read for the reader. Your main idea should be at the top of the paragraph,
        utilize transitional words (first, second, although), consider the connotation of the words that you use.
      </p>
      <p>Example 1: &quot;Hey John, I need you to talk about something urgent when you have time.&quot;</p>
      <p>What would John think about in this message? What&#39;s so urgent?</p>
      <p>
        Example 2: &quot;Hey John, we need some help understanding the requirements in this ticket [link ticket here],
        specifically we have questions about… [list your questions here]&quot;
      </p>
      <p>
        In this 2nd message John knows exactly what ticket you&#39;re referring to, the exact questions you have, and
        knows to be prepared to answer these questions. Most of all, no worry about what exactly this urgent matter is.
      </p>
      <h2 id="cut-to-the-question">Cut to the Question</h2>
      <p>Inspired from: <a href="https://nohello.net/en/">https://nohello.net/en/</a></p>
      <p>
        If you are asking a question to a co-worker, ask the question. Letting the reader know exactly that you have a
        question will get an answer faster.
      </p>
      <p>Example 1: Bob: Hey John: How&#39;s it going? Bob: What time is the meeting? John: Oh, 3:30 today.</p>
      <p>
        This includes common opening phrases &quot;How are you?&quot; or &quot;Hey want to hop in a call?&quot;. Putting
        the reader on the spot dissecting a question in a call can make the recipient feel pressured to get the answer
        now. If you just ask the question first, you&#39;ll get the answer faster.
      </p>
      <p>Instead consider this:</p>
      <p>Example 2: Bob: Hey, what time is the meeting? John: Hey, 3:30 today.</p>
      <p>Straight to the point, no extra words or messages needed.</p>
      <h2 id="avoid-negative-words">Avoid Negative Words</h2>
      <p>Negative words can lead to negative reactions.</p>
      <ul>
        <li>&quot;No&quot; and &quot;Not&quot;</li>
        <li>Reminders of a negative situation</li>
        <li>Doubtful words</li>
      </ul>
      <p>
        How would you react if someone tells you &quot;You can&#39;t.&quot;, &quot;You won&#39;t be able to.&quot;,
        &quot;You failed.&quot;? Human nature is such that you immediately become defensive to language like this.
        Instead, you should focus on what is and can be.
      </p>
      <p>
        Example 1: &quot;I won&#39;t be able to get to your review until Friday.&quot; Better: &quot;I will get to your
        review on Friday.&quot;
      </p>
      <p>
        Example 2: &quot;You can&#39;t reserve Room 110 on June 10th.&quot; Better: &quot;Room 111 is already reserved
        for June 10th, but is available on the 9th or the 11th.&quot;
      </p>
      <p>
        Phrase your writing to offer alternatives to phrases that are usually negative. Be assertive on the
        &#39;when&#39; something will happen or change.
      </p>
      <p>
        Using positive language requires more thought, but is well worth the effort put in to better assist the reader.
      </p>
      <h2>Further Reading</h2>
      <ul>
        <li>
          <a href="https://www.linkedin.com/learning/business-writing-principles"
            >https://www.linkedin.com/learning/business-writing-principles</a
          >
        </li>
        <li>
          <a href="https://nohello.net/en/">https://nohello.net/en/ </a>
        </li>
        <li>
          <a href="https://www.nj.gov/highereducation/documents/pdf/TheScienceofStrongBusinessWriting-HBR2021.pdf"
            >https://www.nj.gov/highereducation/documents/pdf/TheScienceofStrongBusinessWriting-HBR2021.pdf</a
          >
        </li>
        <li>
          <a href="https://hbr.org/2021/07/the-science-of-strong-business-writing"
            >https://hbr.org/2021/07/the-science-of-strong-business-writing</a
          >
        </li>
      </ul>
      <hr />
    </section>

    <section class="post" id="contract-testing">
      <h1 class="postTitle">The Theory Behind Contract Testing</h1>
      <p>
        Below are my notes from the first half of
        <a href="https://www.manning.com/books/contract-testing-in-action">Contract Testing in Action</a>, highly
        recommend this book as this is only the spark notes. Many of the fine details have been left out and are left
        for the book to describe.
      </p>
      <h2 id="what-contract-testing-is-and-why-it-matters">What contract testing is and why it matters</h2>
      <p>
        Contract testing is a form of testing where you test that two systems have a shared understanding of
        expectations.
      </p>
      <p>
        The contract is a JSON file containing the names of two systems interacting. It is the web interface interacting
        with an API. The contract lists all possible interactions between the two systems.
      </p>
      <p>
        There is a shared broker (the contract) which the API can access directly. The API pulls down the contract from
        the shared broker and replays the expected request from the web app and then compares that all responses exist.
      </p>
      <p>
        When there are two users of an API, for example a Mobile client and a Web App, a separate contract can be
        introduced to ensure that changes within the API won’t break either of the applications.
      </p>
      <p>
        Apart from detecting bugs missed by proper communication amongst teams, here are other reasons why contract
        testing can be helpful:
      </p>
      <ul>
        <li>Speeds up development process and provides a faster feedback loop.</li>
        <li>Enables teams to deploy changes independently and safely.</li>
        <li>Issues are easier to debug since scope of tests with the contract is much smaller.</li>
        <li>Developers can run contract tests and update the contract locally.</li>
        <li>Promotes better code quality, removes the need to introduce unneeded requirements.</li>
        <li>
          Ensures breaking changes will be communicated with teams and contract will always be up-to-date with these
          changes.
        </li>
      </ul>
      <h2 id="contracts-on-the-consumer-side">Contracts on the Consumer Side</h2>
      <p>
        Usually the contract is driven from the consumer of the API. Usually the consumer will receive business
        requirements for an application, thus they will create a contract for what fields that they will need.
      </p>
      <p>The frontend engineer will</p>
      <ul>
        <li>Define the interaction with a mock provider.</li>
        <li>Runs the test against the mock provider and verifies the request is registered as an interaction.</li>
        <li>
          If tests are successful, the contract will be generated automatically with includes the defined interaction.
          The frontend engineer will then upload the contract to a shared repository.
        </li>
      </ul>
      <h2 id="contracts-on-the-provider-side">Contracts on the Provider Side</h2>
      <p>
        Contracts will generally be stored in a separate project repository, one of the backend engineers is notified if
        there are updates to the contract. The responsibility of the provider is to verify the contract.
      </p>
      <p>The backend engineer will</p>
      <ul>
        <li>Download the contract generated by the frontend engineer.</li>
        <li>Verifies the expected contract will be returned from the API using a mock consumer.</li>
        <li>If the actual response and the expected response are matching. The verification is successful.</li>
      </ul>
      <p>Contract testing is only useful when you have both a provider side contract and a consumer side contract.</p>
      <h2 id="how-contract-testing-fits">How Contract Testing Fits</h2>
      <p>
        Contract testing is in between the layer of Integration tests and Unit tests. They provide high confidence that
        API endpoints are shaped correctly and allow the developer to confidently know an endpoint will return the data
        needed. Providing early feedback to find any discrepancies and misunderstandings between two teams before
        deploying an application and running integration tests, mitigating compatibility issues found between E2E and
        integration tests.
      </p>
      <p>Contract testing does not replace any of the aforementioned tests, it compliments them.</p>
      <p>Contract testing does not solve:</p>
      <ul>
        <li>Environment problems caused by configuration issues.</li>
        <li>Networking issues such as timeouts and dropped requests.</li>
        <li>Data integrity issues.</li>
        <li>How the user interacts with an application.</li>
        <li>Misunderstandings in business requirements.</li>
      </ul>
      <p>
        When deciding whether to remove a integration or E2E test to a contract test, a good rule of thumb is to move
        tests that can be completely duplicated at the contract level. This gives you confidence that you don&#39;t need
        this as an integration or E2E test. Defining clear contracts between a consumer and a provider ensures that
        developers will only deliver functionalities that align with the consumers needs.
      </p>
      <h1 id="technical-overview-of-contract-testing">Technical Overview of Contract Testing</h1>
      <h2 id="what-is-a-consumer-">What is a Consumer?</h2>
      <p>
        Contract testing puts more power in the hands of the consumer. In day-to-day life, a consumer in a retail
        situation is a &quot;user of a product or service&quot;. Each user may use their product slightly differently
        and/or have different uses of the product.
      </p>
      <p>
        The consumer as it relates to us is generally a web or mobile application that makes requests to a backend
        service. But a consumer can also be a service that is calling another backend service.
      </p>
      <p>
        In a consumer-driven approach to contract testing, the consumer is driving the contract. In the example of a
        login, a consumer dictates when the application requests the login data. An end user does not care about the
        shape or the data, they only care about whether they can log in or not. This is why the consumer is so integral
        and should influence the expected data response.
      </p>
      <h2 id="what-is-a-provider-">What is a Provider?</h2>
      <p>
        A provider is &quot;something that someone needs or wants, if somebody wants your product, you provide them with
        it or make it available&quot;. In a consumer driven approach, the consumer will mock out the provider and the
        provider mocks out their downstream dependencies.
      </p>
      <p>
        The provider must add a test pointing to the consumer within the contract testing process and will automatically
        get updates if they point to the latest version of the consumer contract.
      </p>
      <h2 id="what-is-a-contract-">What is a Contract?</h2>
      <p>
        A contract is “a legal document that states and explains a formal agreement between two different people or
        groups”. It is important to distinguish the differences between a contract and a schema. A schema is described
        as &quot;an outline of a plain or theory&quot;. The schema provides the outline, it will be defined in the
        planning phases before development starts. A contract is used after development to ensure the schema does not
        change after released.
      </p>
      <h2 id="what-is-a-contract-broker-">What is a Contract Broker?</h2>
      <p>
        A broker is “a person who talks to opposing sides, especially governments, making arrangements for them or
        bringing disagreements to an end“. A contract broker is the central place that contracts are stored. Without a
        broker, passing around contracts is manual and can lead to different versions of the most recent contract due to
        code changes.
      </p>
      <h1 id="implementing-consumer-driven-contract-testing-cdct-">
        Implementing Consumer Driven Contract Testing (CDCT)
      </h1>
      <h2 id="the-focus-of-a-consumer-contract">The Focus of a Consumer Contract</h2>
      <p>
        A consumer contract is only supposed to make sure that when a consumer asks for data from a provider service,
        the correct data is returned as specified by the contract agreement. This does not care about the functional
        details of how the provider works, instead they focused on what the consumer needs and checks if they get it.
      </p>
      <p>
        A general rule of thumb when deciding what to include in the contract is: &quot;If I don&#39;t include this
        scenario, what bug in the consumer or what misunderstanding about how the provider responds might be missed. If
        the answer is none, don&#39;t include it.&quot;
        <a href="https://docs.pact.io/consumer#use-pact-for-contract-testing-not-functional-testing-of-the-provider"
          >source</a
        >
      </p>
      <h2 id="building-with-legos">Building with LEGOs</h2>
      <p>
        It is important to understand coupling with contract testing. Think of coupling in the context of LEGO blocks.
        In a highly coupled scenario, LEGO blocks are intertwined and connected with other blocks, if you remove 1, the
        whole structure falls. These blocks are highly dependent on each other and depend on one block being present.
      </p>
      <p>
        In contract testing you are able to smell a highly coupled contract if you make one small change to the provider
        and the consumer contract fails. If you&#39;re not careful, contract tests can easily become very brittle and
        flaky.
      </p>
      <p>
        To combat flaky tests, Pact provides loose matchers, such as type based matchers. With type based matching, you
        care about what is the type of data returned, rather than the actual data itself. Consider the code sample below
      </p>
      <pre>
      <code class="lang-js">
      const EXPECTED_BODY = {
          id: <span class="hljs-keyword">like</span>(<span class="hljs-number">1</span>),
          username: <span class="hljs-keyword">like</span>(<span class="hljs-string">'marie'</span>),
          fullname: <span class="hljs-keyword">like</span>(<span class="hljs-string">'marie cruz'</span>)
      }</code>
    </pre>
      <p>
        This object represents the shape the consumer expects from the data provider. If the consumer makes a GET
        request, it cares that the data exists, and the type of the data matches. Another question that Pact recommends
        is &quot;If I made this looser/tighter, what bugs would I miss/prevent?&quot;
      </p>
      <h2 id="example-consumer-jest-test">Example Consumer Jest test</h2>
      <p>A consumer contract test can be broken down into 5 steps</p>
      <ol>
        <li>Importing the required dependencies.</li>
        <li>Setting up mock provider that the consumer will use.</li>
        <li>Registering the expectations that the consumer will receive from the provider.</li>
        <li>Verifying the consumer test and generate the contract.</li>
        <li>Publish the contract to a broker.</li>
      </ol>
      <pre>
      <code class="lang-js">
      <span class="hljs-keyword">const</span> path = require(<span class="hljs-string">"path"</span>);
      <span class="hljs-keyword">const</span> { fetchMovies } = require(<span class="hljs-string">"./consumer"</span>);
      <span class="hljs-keyword">const</span> { PactV3, MatchersV3 } = require(<span class="hljs-string">"@pact-foundation/pact"</span>);
      
      <span class="hljs-keyword">const</span> provider = <span class="hljs-keyword">new</span> PactV3({
        dir: path.resolve(process.cwd(), <span class="hljs-string">"pacts"</span>),
        consumer: <span class="hljs-string">"WebConsumer"</span>,
        provider: <span class="hljs-string">"MoviesAPI"</span>,
      
      });
      
      <span class="hljs-keyword">const</span> EXPECTED_BODY = { id: <span class="hljs-number">1</span>, name: <span class="hljs-string">"My movie"</span>, year: <span class="hljs-number">1999</span> };
      
      describe(<span class="hljs-string">"Movies API"</span>, () =&gt; {
        describe(<span class="hljs-string">"When a GET request is made to /movies"</span>, () =&gt; {
          test(<span class="hljs-string">"it should return all movies"</span>, <span class="hljs-keyword">async</span> () =&gt; {
            provider
              .uponReceiving(<span class="hljs-string">"a request for all movies"</span>)
              .withRequest({
                method: <span class="hljs-string">"GET"</span>,
                path: <span class="hljs-string">"/movies"</span>,
              })
              .willRespondWith({
                status: <span class="hljs-number">200</span>,
                body: MatchersV3.eachLike(EXPECTED_BODY),
              });
      
            <span class="hljs-keyword">await</span> provider.executeTest(<span class="hljs-keyword">async</span> (mockProvider) =&gt; {
              <span class="hljs-keyword">const</span> movies = <span class="hljs-keyword">await</span> fetchMovies(mockProvider.url);
              expect(movies[<span class="hljs-number">0</span>]).toEqual(EXPECTED_BODY);
            });
      
          });
      
        });
      
      });
      </code></pre>
      <p>
        The test above generates a contract <code>WebConsumer-MoviesAPI.json</code> using Pact to be uploaded to a
        shared broker.
      </p>
      <h1 id="implementing-cdcts-for-providers">Implementing CDCTs for Providers</h1>
      <p>
        When developing contract tests, it is essential to keep in mind that there are two sets of tests that you need
        to write, one for the consumer, the other for the providers. Provider contract tests typically demand less code
        than it&#39;s counterpart.
      </p>
      <h3 id="the-focus-of-a-provider-contract-test">The Focus of a Provider Contract Test</h3>
      <p>
        The primary focus of a provider contract test is to verify the contract that the consumer has generated.
        Contract testing tools, such as Pact, provide a framework that allows data providers to pull the contract test
        and replay the interactions that the consumer registers as part of the contract.
      </p>
      <p>
        A consumer-driven contract testing approach forces the provider to only develop features that the consumer
        requires. If the API introduces a breaking change that modify the type of a field, the contract should verify
        this change before applying it to production. To reiterate, contract testing should <em>NOT</em> verify
        validation, this should be a unit test.
      </p>
      <p>
        If the provider changes the business logic of a validation, this would break a contract testing validation.
        Ideally business rules should not break a contract with a consumer.
      </p>
      <h3 id="using-provider-states-effectively">Using Provider States Effectively</h3>
      <p>
        Provider states allow data providers to define the state a response needs to be in to be able to verify the
        interaction from the consumer contract successfully. When writing a provider contract test with provider states,
        you need to make sure that the provider state is provided from the consumer.
      </p>
      <ol>
        <li>Set up the consumer test with a provider state.</li>
        <li>Define the state of the provider.</li>
      </ol>
      <h2 id="example-provider-jest-test">Example Provider Jest Test</h2>
      <p>A provider contract test can be broken down into 5 steps</p>
      <ol>
        <li>Importing the required dependencies.</li>
        <li>Running the provider service.</li>
        <li>Setting up the provider verifier options.</li>
        <li>Writing the provider contract test.</li>
        <li>Running the provider contract test.</li>
      </ol>
      <pre><code class="lang-Js">const { Verifier } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@pact-foundation/pact'</span>);
      const { importData, server } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./provider'</span>);
      
      importData();
      
      const port = <span class="hljs-string">'3001'</span>;
      const app = server.listen(port, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(`<span class="javascript">Listening on port ${port}...</span>`));
      
      const options = {
          provider: <span class="hljs-string">'MoviesAPI'</span>,
          providerBaseUrl: `<span class="javascript">http:<span class="hljs-comment">//localhost:${port}</span></span>`,
          pactBrokerUrl: process.env.PACT_BROKER_BASE_URL,
          pactBrokerToken: process.env.PACT_BROKER_TOKEN,
          providerVersion: <span class="hljs-string">'1.0.0'</span>,
          publishVerificationResult: <span class="hljs-literal">true</span>,
          consumerVersionTags: [<span class="hljs-string">'main'</span>],
      };
      
      const verifier = <span class="hljs-keyword">new</span> Verifier(options);
      
      describe(<span class="hljs-string">'Pact Verification'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
          test(<span class="hljs-string">'should validate the expectations of movie-consumer'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
              <span class="hljs-keyword">return</span> verifier
                  .verifyProvider()
                  .<span class="hljs-keyword">then</span>(
                      output =&gt; {
                          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Pact Verification Complete!'</span>);
                          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Result:'</span>, output);
                          app.close();
                  });
          });
      });
      </code></pre>
    </section>
  </body>
</html>
